<?php

/**
 * Implements hook_init.
 * 
 * @return type
 */
function idu_init( ) {
  module_load_include('inc', 'repository_control');
  module_load_include('inc', 'repository_control', 'log_record');
  module_load_include('inc', 'repository_control', 'csv_cells');
  module_load_include('inc', 'repository_control', 'object_record');
  /* module_load_include('inc', 'phpexcel'); */
  module_load_include('inc', 'islandora_paged_content', 'includes/utilities');
  module_load_include('inc', 'islandora_paged_content', 'includes/manage_pages');
  module_load_include('inc', 'idu', 'idu_constants');
  module_load_include('inc', 'islandora_audio', 'includes/derivatives');
  return;
}

/** 
 * Implements hook_help.
 * 
 * @param type $path
 * @param type $arg
 * @return type
 */
function idu_help($path, $arg) {
  if ($path == 'admin/help#idu') {
    return t('Islandora Health Check allows a site administrator to report on, and subsequently act on, the health of a repository.');
  }
}

/**
 * Implements hook_phpexcel_export.
 *
 * This function examines the contents of each cell, before it is 'printed' into
 * the XSLX file, and sets the cell format based on the content.  Supported codes
 * in the cells produce the following effects in rank order...
 *
 * %RED% - Sets cell background fill to red (#FFADAD).
 * %YELLOW% - Sets cell background fill to yellow (#FFFF66).
 * %GREEN% - Sets cell background fill to green (#99FF99).
 * %BOLD% - Bold black font.
 * %SOFT% - Subdued or 'greyed out' cell font (#B8B8B8).
 * %NORMAL% - No formatting.
 *
 * %WIDTH:xx% - Set the column width to xx.  Usually appears in the first row of data.
 *
 * The format code is removed from the cell content before printing and a cell
 * can contain ONLY ONE CODE!
 *
 * @param type $op
 * @param type $data
 * @param type $phpexcel
 * @param type $options
 * @param type $column
 * @param type $row
 *
function idu_phpexcel_export($op, &$data, $phpexcel, $options, $column=NULL, $row=NULL) {
  $matches = array( );

  switch($op) {
    case 'pre cell' :

      // If $row ONE...set column width.
      if ($row === 1) {
        if ($column > 0) {
          $col = substr('_ABCDEFGHIJKLMNOPQRSTUVWXYZ', $column, 1);
          $width = iduColWidth($col);
          $phpexcel->getColumnDimension($col)->setWidth($width);
        } else {
          $phpexcel->freezePane('A2');
        }
      }

      // If a code was found...
      if (preg_match('/^%(.+)%(.+)$/', $data, $matches)) {
        $code = $matches[1];

        switch($code) {
          case 'RED' :
          case 'ORANGE' :
          case 'YELLOW' :
          case 'GREEN' :
            $codes = iduCodes( );
            $style = PHPExcel_Style_Fill::FILL_SOLID;
            $phpexcel->getStyleByColumnAndRow($column,$row)->getFill()->
            applyFromArray(array('type'=>$style, 'startcolor'=>array('rgb'=>$codes[$code])));
            break;
          case 'BOLD' :
            $phpexcel->getStyleByColumnAndRow($column,$row)->getFont()->setBold(TRUE);
            break;
          case 'SOFT' :
            $codes = iduCodes( );
            $phpexcel->getStyleByColumnAndRow($column,$row)->getFont()->getColor()->setRGB($codes['SOFT']);
            break;
          case 'NORMAL' :
            // Nothing to do here...no formatting.
            break;
        }
        $data = $matches[2];
      }
      break;
  }
}

/**
 * Implements hook form.
 * 
 * @param type $form
 * @param type $form_state
 * @return type
 */
function idu_main_form($form, &$form_state) {
  if (!isset($form_state['storage']['confirm'])) {
    
    $form['operation'] = array(
        '#type' => 'select',
        '#title' => t('Select the operation to be performed.'),
        '#default_value' => variable_get('icg_operation', 'HEALTH_CHECK'),
        '#options' => array(
          'OPEN_REPORT' => t('  OPEN_REPORT - Present a link to download / open the specified XLSX health check report. '),
        ),
    );
    
   $form['submit'] = array(
        '#type' => 'submit',
        '#value' => t('Submit'),
    );

    return $form;
    
  } else {  // The confirmation (secondary) form.
    
    $op = $form_state['values']['operation'];
    $default_file = variable_get('icg_xlsxFile', "public://HEALTH_CHECK.xlsx");
    
    if ($op === 'OPEN_REPORT') {
      $form['xlsxFile'] = array(
       '#type' => 'textfield',
       '#title' => t('Enter the name of the existing XLSX file to open. '),
       '#default_value' => $default_file,
       '#size' => 80,
       '#maxlength' => 80,
      );
    } else {
      $form['first'] = array(
       '#type' => 'textfield',
       '#title' => t('Enter the first PID number to process.'),
       '#default_value' => variable_get('icg_first', '0'),
       '#size' => 10,
       '#maxlength' => 10,
      );
      $form['last'] = array(
        '#type' => 'textfield',
        '#title' => t('Enter the last PID number to process.'),
        '#default_value' => variable_get('icg_last', '10000'),
        '#size' => 10,
        '#maxlength' => 10,
      );
      $form['inactives'] = array(
        '#type' => 'checkbox',
        '#title' => t('Check here if you want to include inactive and empty (deleted) objects.'),
        '#default_value' => variable_get('icg_inactives', FALSE),
      );
    }

  }
    
  $alias = variable_get('icg_repoAlias');
  $namespace = variable_get('icg_namespace');
  return confirm_form($form, " Operation '$op' - Proceed with the specified inputs and the '$namespace' namespace of '$alias'? ", 'idu', '  This action cannot be undone. ', $op, 'Cancel');
  
}

/**
 * Implements hook_form_validate.
 *  
 * @param type $form
 * @param type $form_state
 * @return type
 */
function idu_main_form_validate($form, &$form_state) {
  return;
}

/**
 * Implements hook_form_submit.
 * 
 * @param type $form
 * @param type $form_state
 * @return type
 */
function idu_main_form_submit($form, &$form_state) {

  // If confirm is NOT set, this will cause the form to be rebuilt, entering the confirm part.
  if (!isset($form_state['storage']['confirm'])) {

    $form_state['storage']['confirm'] = TRUE;
    $form_state['storage']['original_form'] = $form_state['values'];
    $form_state['rebuild'] = TRUE;
      
  } else {  // Do real form submittal.
    
    drupal_set_message(t('The Islandora Health Check main form has been submitted.'));

    $main = $form_state['storage']['original_form'];   // get controls from the main form
    $secondary = $form_state['values'];                // get controls from the secondary form

    icg_set_variable('operation', $main);

    icg_set_variable('first', $secondary);
    icg_set_variable('last', $secondary);
    icg_set_variable('inactives', $secondary);
    icg_set_variable('onlyCols', $secondary);
    icg_set_variable('xlsxFile', $secondary);

    idu_op( );  // Distribute control to the specified $op.
    }
    
  return;
}

/**
 * Defines the function called at the end of batch processing.
 * 
 * @param type $success
 * @param type $results
 * @param type $operations
 */
function idu_op_batch_finished($success, $results, $operations) {
  if (!$success) {
    $error_operation = reset($operations);
    drupal_set_message(t('An error occurred while processing @operation with arguments : @args', array('@operation' => $error_operation[0], '@args' => print_r($error_operation[0], TRUE))));
  } else {
    $op = variable_get('icg_operation');
    $first = variable_get('icg_first');
    $last = variable_get('icg_last');
    $msg = "$op batch processing is complete for PIDs $first to $last.";
    drupal_set_message($msg, 'status');
  }
}

/**
 * Implements hook_menu().
 * 
 * @return type
 */
function idu_menu( ) {
  $items = array();
  $items['idu'] = array(
      'title' => 'Islandora Health Check',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('idu_main_form'),
      'description' => 'Islandora Health Check',
      'access arguments' => array('administer users'),
      'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Returns an associative array of PIDS found in the specified range.
 * 
 * @param array $context
 *   Drupal batch $context array.  Returns with an associative array of 
 *   PIDnum => Title values in $context['sandbox']['objPIDs'] for objects 
 *   found in the specified range.
 * @return integer
 *   The PID number of the last/highest numbered PID found in the range. The
 *   variable icg_last is automatically set to this limiting value.
 */
function idu_getPIDs(&$context) {
  $obj_pids = array();
  $first = intval(variable_get('icg_first'));
  $last = intval(variable_get('icg_last'));
  $range = $last - $first + 1;
  $largest = 0;
  
  $ns = variable_get('icg_namespace');

  // Loop through the repo looking for objects in the specified range.

  for ($i=$first, $notFound=0; $i<=$last; $i++) {
    $pid = $ns.$i;
    try {
      $object = idu_repo( )->getObject($pid);
    } catch (Exception $e) {
      if ($e->getCode() === 404) {
        $obj_pids[$i] = '-*-Not Found-*-';
        $notFound++;
      } else {
        drupal_set_message("PID '$pid' forced a FedoraRepository getObject( ) exception: '$e' ", 'error');
      }
      continue;  // for any exception...skip this PID
    }
    $obj_pids[$i] = $object->label;
    $largest = $i;
  }

  // If any PIDs were not found, report them.
  if ($notFound > 0) {
    if ($range > 10) {
      drupal_set_message("A total of $notFound PIDs in the specified range were NOT FOUND.", 'warning');
    }
    foreach ($obj_pids as $pid => $status) {
      if ($status === '-*-Not Found-*-') {
        if ($range<=10 && variable_get('icg_verbose')) {
          drupal_set_message("Object $pid was NOT FOUND.", 'warning');
        }
        unset($obj_pids[$pid]);  // remove it from our list
      }
    }
  }

  // Save the found object PIDs in the batch results.
  $context['results']['objectPIDs'] = $obj_pids;
  idu_post($context);
  
  variable_set('icg_last', $largest);
  return $largest;
}

/**
 * Open the repository for the rest of FHC to use.
 * 
 * @global FedoraRepository $repository
 * @return FedoraRepository 
 */
 function idu_repo( ) {
  global $repository;
  if (!is_null($repository)) {
    return $repository;
  } else if (!$repository = repository_control_connect()) { 
    die('Error in idu_repo( )...no connection to Fedora!'); 
  } 
  return $repository;
}

/**
 * Returns a target object or FALSE if not found.
 * 
 * This function is meant to be called near the top of each batch function.
 * 
 * @param integer $pidn
 * @param array $context
 * @return boolean|FedoraObject
 */
function idu_fetch($pidn, &$context) {
  $pid = variable_get('icg_namespace').$pidn;
  
  if (!isset($context['results']['objectPIDs'])) {
    die('ObjectPIDs are not available in idu_fetch( )!');
  } else if (!array_key_exists($pidn, $context['results']['objectPIDs'])) {
    return FALSE;
  }

  // Fetch the target object and it's title, update the progress message and Go!
  if (!$object = idu_repo( )->getObject($pid)) { return FALSE; }
  
  $context['sandbox']['current_pid'] = $pid;
  if (variable_get('icg_verbose')) {
    $context['results'][pidn($pid)][] = "Object '$pid' fetched. Title = '$object->label'";
  }
  return $object;
}

/**
 * Increments the batch progress counter.
 * 
 * @param array $context
 */
function idu_post(&$context) {
  icg_increment($context['results']['progress']);
  $context['finished'] = 1.;
}

/**
 * Print an output report and CSV from the $op and return it.
 *
 */
function idu_print_results(&$context) {
  
  // Open the CSV file to write...
  $csvName = 'public://fedora_health_check.csv';
  if (!$csv = fopen($csvName, 'w')) {
    die("FHC was unable to open CSV file '$csvName' for output!");
  }
  
  // Write and report the CSV...
  $record = array();
  for ($r=variable_get('icg_first'); $r<=variable_get('icg_last'); $r++) {
    if ($row = or_get(0, $r)) {
      $nCol = count($row);
      for ($c=1; $c<=$nCol; $c++) {
        if (!isset($row[$c])) {
          $record[] = ' ;';
        } else {
          $record[] = $row[$c];
        }
      }
    } else {
      $record[] = ' ';
    }
    
    fputcsv($csv, $record, ";");
  }
  
  fclose($csv);
  
  $url = file_create_url($csvName);
  $_SESSION['idu_csv_file'] = $csvName;
  drupal_set_message(t('Saved CSV file as %csvName (accessible via !url, uri=<span id="uri">@uri</span>)', array('%csvName' => $csvName, '@uri' => $csvName, '!url' => l(t('this URL'), $url, array("attributes" => array("target" => "_blank"))))));
  idu_post($context);

  return;
}

/**
 * Distributes operation control within the module.  It ALL happens here.
 * 
 * @return NONE
 */
function idu_op( ) {

  // Retrieve the scope of work parameters...$first, $last and $op.
  $first = intval(variable_get('icg_first'));
  $last = intval(variable_get('icg_last'));
  $onlyCols = variable_get('icg_onlyCols');
  $op = variable_get('icg_operation');
    
  // If we just want to open the last report...do it here.    
  if ($op === 'OPEN_REPORT') {
    idu_open_report( );
    return;
  }

  // If we just want to create a new report...do it here.
  if ($op === 'CREATE_REPORT') {
    idu_write_xlsx( );
    return;
  }
    
  // Declare an array of batch operations and make idu_getPIDs the first one
  // if this is a full HEALTH_CHECK. 
  $operations = array( );
  if ($op === 'HEALTH_CHECK') { $operations[] = array('idu_getPIDs', array( )); }
      
  // Build an array of operations based on $op.
  // $operations[] = array( <function name>, <array of arguments to pass to function> );
  
  for ($r=$first; $r<=$last; $r++) {
    switch ($op) {
      case 'HEALTH_CHECK' :
        $operations[] = array('idu_object_health', array($r, $onlyCols));
        break;
      case 'ANALYZE_DATA' :
        $operations[] = array('idu_analyze_data', array($r));
        break;
      case 'CREATE_REPORT' :
        $operations[] = array('idu_write_xlsx', array( ));
        break;
    }  // end of... switch($op)
  }  // end of... for ($r=$first; $r<=$last; $r++) 

  build_batch_set($op, $operations, 'idu_op_batch_finished');
  batch_process('idu');    // git 'er done!

  return;
}

/**
 * Analyze existing CSV data by applying a set of specified rules.
 * 
 */
function idu_analyze_data($r, &$context) {
  $row = $codes = array( );

  if ($row = or_get(0, $r)) {
    if ($codes = idu_apply_rules($row)) {
      foreach ($codes as $c => $code) {
        or_set_code($c, $r, $code);
      }
    }
  }

  // Check for a gap in the PID numbering.
  if (empty($context['results']['previousPID'])) {
    $change = 0;
  } else {
    $change = $r - intval($context['results']['previousPID']);
  }
  $context['results']['previousPID'] = $r;

  if ($change > 4 || $change == 0) {
    or_set_code(1, $r, 'ORANGE');
  } else if ($change > 1) {
    or_set_code(1, $r, 'YELLOW');
  } else {
    or_set_code(1, $r, 'NORMAL');
  }

  // Update $context.
  idu_post($context);

  return;
}

/**
 * Write existing CSV data to an Excel 2007+ .xslx file, with color!
 * 
 * @return string
 *   The name of the XSLX file created. 
 */
function idu_write_xlsx( ) {

  // Set properties
  $title = "Islandora Health Check - ".date('Y-m-d H:i:s');
  $description = "Islandora Health Check of '".variable_get('icg_repoAlias')."' for Office 2007 XLSX, generated using PHP classes.";
  
  $param = array('format'=>'xlsx', 'creator'=>'Mark McFate', 
    'title'=>$title, 'subject'=>"Islandora Health Check", 'description'=>$description);
  $headers = iduColumns(1, NULL, FALSE);  // don't preserve keys here!

  // Set some progress info.
  $first = variable_get('icg_first');    
  $last = variable_get('icg_last');    
  $range = $last - $first + 1;

  if (function_exists('drush_main')) { 
    $start = date('H:i:s');
    drush_log("idu_write_xlsx: Beginning data retrieval for PIDs $first to $last at $start.", 'ok');
  }

  // Read the data, apply formatting and save it in $sheet.
  $sheet = array( );
  for ($i=0, $p=0, $r=$first; $r<=$last; $r++, $p++) {
    if ($row = or_get(0, $r)) {
      if (variable_get('icg_inactives') || !empty($row[3])) { 
        $codes = or_get_code(0, $r);
        $sheet[$i] = idu_fill_sheet($row, $codes);
        ++ $i;
      }
    }
    
    // If running in drush, report our progress.
    if (function_exists('drush_main')) { idu_drush_print_progress('idu_write_xlsx', $p, $range-1); }
  }
  
  // Save Excel 2007 file
  $xlsxName = variable_get('icg_xlsxFile');
  $path = drupal_realpath($xlsxName); 
  if (function_exists('drush_main')) { drush_log("idu_write_xlsx: Beginning PHPExcel export to $path.", 'ok'); }
  $result = phpexcel_export($headers, $sheet, $path, $param);
    
  if ($result === PHPEXCEL_SUCCESS) {
    $url = file_create_url($xlsxName);
    $_SESSION['idu_xlsx_file'] = $xlsxName;
    drupal_set_message(t('Saved XLSX file as %xlsxName (accessible via !url, uri=<span id="uri">@uri</span>)', array('%xlsxName' => $xlsxName, '@uri' => $xlsxName, '!url' => l(t('this URL'), $url, array("attributes" => array("target" => "_blank"))))));
  } else {
    $msg = "Error writing the XLSX file. Result code = '$result'.";
    drupal_set_message(t($msg), 'error');
  }    

  return $xlsxName;

}

/**
 * Open an existing XLSX report for download.
 * 
 */
function idu_open_report( ) {
  $xlsxName = variable_get('icg_xlsxFile');
  if (is_file($xlsxName)) {
    $url = file_create_url($xlsxName);
    $_SESSION['idu_xlsx_file'] = $xlsxName;
    drupal_set_message(t('XLSX file %xlsxName was found and is accessible via !url, uri=<span id="uri">@uri</span>.', array('%xlsxName' => $xlsxName, '@uri' => $xlsxName, '!url' => l(t('this URL'), $url, array("attributes" => array("target" => "_blank"))))));
  } else {
    $msg = "Sorry, unable to find a readable XLSX file at '$xlsxName'!";
    drupal_set_message(t($msg), 'error');
  }
}

/**
 * Set cell code to RED, YELLOW, GREEN, BOLD, SOFT or NORMAL.
 * 
 * @param string $code
 *   The intended cell code.
 * @param string $cell
 *   The intended cell contents.
 * @param boolean $ignoreRank
 *   Set to TRUE if code rank is to be ignored. 
 * @return string
 *   The modified cell contents.
 */
function idu_set_cell($code, $cell, $ignoreRank=FALSE) {
  $text = $cell;
    
  // If an invalid code was passed, ignore it.
  if (!array_key_exists($code, iduCodes( ))) { return $text; }
  
  // Check for an existing code within the cell.  Got one?
  $matches = array( );
  if (preg_match('/^%(.+)%(.+)$/', $cell, $matches)) {
    $current = $matches[1];

    // If $code is NORMAL and $ignoreRank is TRUE, return the text with NO code at all.
    if ($code === 'NORMAL' && $ignoreRank) { return $matches[2]; }
    
    // Fetch the rank of $code and $current.  Zero (red) has precedence.
    $rCode = array_search($code, iduCodeRank( ));
    $rCurrent = array_search($current, iduCodeRank( ));
    
    // If $code ranks over $current, or if rank is ignored, apply it.  If not, ignore it.
    if ($rCode < $rCurrent || $ignoreRank) { $text = "%$code%$matches[2]"; }
    return $text;
  
  // No existing code...
    
  } else if ($code === 'NORMAL') {   // If new $code is NORMAL, apply nothing.
    return $text; 

  } else {                           // New $code is NOT NORMAL, apply it.
    $text = "%$code%$cell";
    return $text;
  }
}

/**
 * Identify missing datastreams for one existing object.
 * 
 * @param FedoraObject $object
 * @param string $cModel
 */
function idu_identify_missing_datastreams($object, $cModel) {
  $missing = '';
  $mCountR = 0;
  
  // Check first for all required datastreams.        
  $required = array('MODS','DC','OBJ','TN');
  foreach ($required as $requiredDS) {
    if (!$object[$requiredDS]) { 
      $missing .= "$requiredDS "; 
      ++ $mCountR; 
    }
  }
    
  // Now, given the cModel, check for missing derivatives.
  switch ($cModel) {
    case 'sp_pdf' :
      $derivatives = array('FULL_TEXT','TECHMD','PREVIEW');
      break;
    case 'sp_large_image_cmodel' :
      $derivatives = array('JPG','JP2','TECHMD'); 
      break;
    case 'sp_basic_image' :
      $derivatives = array('MEDIUM_SIZE','TECHMD');
      break;
    case 'sp-audioCModel' :
      $derivatives = array('PROXY_MP3','TECHMD');
      break;
    case 'sp_videoCModel' :
      $derivatives = array('TECHMD_FITS','TECHMD','MP4');
      break;
    case 'bookCModel' :
      $derivatives = array('PDF'); 
      $missing = str_replace('OBJ ','',$missing);  // No OBJ required here.
      -- $mCountR;
      break;
    case 'pageCModel' :
      $derivatives = array('PDF','TIFF','JPG','OCR','JP2','RAW_HOCR','HOCR'); 
      $missing = str_replace('MODS ','',$missing);  // No MODS required here.
      -- $mCountR;
      break;
    case 'compoundCModel' :
      $derivatives = array( );   // None required
      $missing = str_replace('OBJ ','',$missing);  // No OBJ required here.
      -- $mCountR;
      break;
    case 'binaryObjectCModel' :
      $derivatives = array( );   // None required
      $missing = str_replace('TN ','',$missing);  // No TN required here.
      -- $mCountR;
      break;
    case 'sp_web_archive' :
      $derivatives = array('PDF','WARC_CSV','WARC_FILTERED','PNG','JPG','MEDIUM_SIZE');
      break;
  }
  
  // Count and identify missing derivatives.
  $mCTotal = $mCountR;
  if (!empty($derivatives)) {
    foreach ($derivatives as $d) {
      if (!$object[$d]) { 
        $missing .= "$d "; 
        ++ $mCTotal;
      }
    }
  }

  // Report all the missing...
  if ($mCountR > 0) {
    $missing = "[$mCTotal] $missing!";  // ! indicates that required are among the missing
  } else if ($mCTotal > 0) {
    $missing = "[$mCTotal] $missing";   // no !, only derivatives missing
  } else {
    $missing = '';
  }

  return trim($missing);
}

/**
 * Return the count and content from an existing health check cell.
 * 
 * @param string $cell
 * @return array
 */
function idu_get_count_and_content($cell) {
  $matches = array( );
  if (empty($cell)) {
    return array(0, NULL);
  } else if (preg_match('/^\[(\d+)] (.+)$/', $cell, $matches)) {  // count and content
    return array(intval($matches[1]), trim($matches[2]));
  } else if (preg_match('/^\[(\d+)]$/', $cell, $matches)) {  // count only
    return array(intval($matches[1]), NULL);
  } else if (preg_match('/^(.*)$/', $cell, $matches)) {  // content only
    $content = $matches[1];
    return array(1, trim($content));
  }  
}

/**
 * Check this object and the previous one for a probable TIFF/JPEG duplication.
 * 
 * @param array $row
 *   The row of object data to be tested against the previous object's data.
 * @return boolean|string
 *   Returns FALSE if this is not a probable duplication, otherwise the common
 *   parent PID is returned.
 */
function idu_special_caseX($row) {
  static $lastPIDn = NULL;
  static $lastParent = NULL;
  static $lastMIME = NULL;
  
  $parent = FALSE;
  
  // First time called...prep for the next call.
  if (is_null($lastPIDn)) {
    list($count, $lastPIDn) = idu_get_count_and_content($row[1]);
    list($count, $lastParent) = idu_get_count_and_content($row[6]);
    list($count, $lastMIME) = idu_get_count_and_content($row[7]);
    return FALSE;
  }
  
  // Not the first call...check for special case 1.
  if ($row[1] = $lastPIDn-1) {  // consecutive PID numbers
    if ($lastParent === $row[6]) {  // same parent
      if ($row[7] === 'image/jpeg' && $lastMIME === 'image/tiff') {  // we have a TIFF followed by a JPEG
        $parent = $row[6];
      }
    }
  }
  
  // Prep for the next row.
  $lastPIDn = $row[1];
  $lastParent = $row[6];
  $lastMIME = $row[7];

  return $parent;
}

/**
 * 
 * @param type $oldContent
 * @return type
 */
function idu_special_case2($oldContent) {
  if (empty($oldContent)) { return FALSE; }
  $jpegs = $tiffs = 0;
  list($n, $content) = idu_get_count_and_content($oldContent);
  if (empty($content) || (count($content) < 2)) { return FALSE; }

  foreach ("$content" as $token) {
    list($mime, $count) = explode(':', $token);
    if (in_array($mime, array('image/jpeg','image/jpg'))) {
      $jpegs += $count;
    } else if (in_array($mime, array('image/tiff','image/tif'))) {
      $tiffs += $count;
    }
  }
  return ((($jpegs === $tiffs) && ($jpegs > 0)) ? TRUE : FALSE);
}

/**
 * Return the number of OLD (genericCModel) original content datastreams.
 * 
 * @staticvar array $labels
 *   List of old derivative labels.  DS's with these labels are NOT original content. 
 * @param FedoraObject $object
 *   The object to be examined.
 * @param int $count
 *   Returned count of OLD, original content datastreams.  
 * @return array|boolean
 *   Associative array of MIMEtype => count, or FALSE if none.
 */
function idu_count_old_content($object, &$count) {
  // The following are known derivative labels.  Don't count them!  
  static $labels = array('pdf to swf','jpeg to swf','thumbnail','compressed mp4',
    'JPEG 2000,','Medium sized JPEG', 'compressed to mp3');
  $mimeCount = array( );
  $count = 0;
  
  foreach($object as $ds) {
    $id = $ds->id;

    // If the DSID is not a known type... we have some work to do.
    if ($id != 'OBJ' && !in_array($id, rcDSIDs( ))) {
      $label = $ds->label;
      if (!in_array($label, $labels)) {
        ++ $count;
        $mime = $ds->mimetype;
        if (empty($mimeCount[$mime])) {
          $mimeCount[$mime] = 1;
        } else { 
          ++ $mimeCount[$mime];
        }
      }
    }
  }
  
  return ($count > 0 ? $mimeCount : FALSE);
}

/**
 * Apply assessment rules to one row ($columns) of data.
 * 
 * @param array $columns
 *    The row of data to be analyzed.
 * @return array
 *   An associative array of format codes in $column => $code form.
 */
function idu_apply_rules(array $columns) {
  $row = array( );
  $isGreen = TRUE;
  
  // Get the object...
  $pid = $columns[2];
  if ($pid === '*None*') {
    $row[2] = 'SOFT'; 
    return $row;
  }
  
  // Not skipped, eh?  Check the object state and report.
  if (!empty($columns[3])) {
    list($fixed, $state) = idu_get_count_and_content($columns[3]);
    if ($state != "A") { 
      $row[2] = 'SOFT'; 
      return $row;
    }
  }
  
  // Ok, we have an active object...get busy.  Start by reporting some basic info. 
  $row[2] = 'BOLD';
  
  // Report the total number of datastreams.
  if (!empty($columns[4])) {
    $nDS = $columns[4]; 
    if ($nDS > 19) { $row[4] = 'YELLOW'; }
  }
  
  // Check the CModels.  If no RELS-EXT...report that here.
  if (!empty($columns[5])) {
    $cm = $columns[5];
    if ($cm === '*No RELS-EXT*') {
      $row[5] = 'RED';
      $isGreen = FALSE;
      return;
    } else {
      list($nCM, $cModel) = idu_get_count_and_content($cm);
      if ($nCM > 2) {
        $row[5] = 'RED'; 
        $isGreen = FALSE;
      } else if ($nCM != 1 ) {
        $row[5] = 'YELLOW'; 
      }
    }
  }
  
  // Fetch and report all the parent (isMemberOfCollection, isConstituentOf and 
  // isPageOf) relationships.
  if (!empty($columns[6])) {
    list($nRel, $parent) = idu_get_count_and_content($columns[6]);
    if ($nRel > 2) {    // more than two parents, not good.
      $row[6] = 'RED';
      $isGreen = FALSE;
    }
  }
  
  // Check the OBJ datastream.
  if (!empty($columns[7])) {  
    $OBJMimes = rcOBJMimes( );
    $mime = $columns[7];
    if (!isset($OBJMimes[$cModel])) {
      $row[7] = 'YELLOW';               // better check our rcOBJMimes list!
    } else {
      $expected = $OBJMimes[$cModel];
      if ($mime != $expected) { 
        $row[7] = 'RED';                // red if not the expected type
        $isGreen = FALSE;
      }
    }
  }

  // Bad mimes...always red if not blank.
  if (!empty($columns[8])) {
    $bad = $columns[8];
    if (strlen($bad) > 0 ) { 
      $row[8] = 'RED'; 
      $isGreen = FALSE;
    }
  }
  
  // Other DSIDs, $row[9], is OK, no rules to apply.
  
  // Missing datastreams...red for ! missing required DS, yellow otherwise.
  // Except... RAW_HOCR's are not absolutely required, neither are TECHMDs.
  static $allowed = array('[1] TECHMD', '[1] RAW_HOCR');

  if (!empty($columns[10])) {
    $missing = $columns[10];
    if (strlen($missing) > 0 ) { 
      if (strstr($missing, '!')) {
        $row[10] = 'RED'; 
        $isGreen = FALSE;
      } else if (!in_array($missing, $allowed)) {
        $row[10] = 'YELLOW';
      } else {
        $row[10] = 'NORMAL';
      }
    }
  }
  
  // Check for old content issues.
  if (!empty($columns[11])) {
    if (strlen($columns[11]) < 1) {
      $row[11] = 'YELLOW';           // No old content?
      $count = 0;
    }
        
    // If the OLD content count is greater than 1 and this is not a compoundCModel...big problem!
    if ($count > 1 && $cModel != 'compoundCModel') { 
      $row[5] = 'RED'; 
      $isGreen = FALSE;
    }
  }

  // Check for bad isPartOf references and set cell yellow if any are found.

  if (!empty($columns[13])) {
    list($nPart, $content) = idu_get_count_and_content($columns[13]);
    $parts = explode(',', $content);
    if ($nPart != count($parts)) {          // number of reported isPartOf is inconsistent
      $row[13] = 'YELLOW';
    } else {
      foreach ($parts as $part) {
        if (preg_match('/^grinnell\:/', trim($part))) {  // this is an old grinnell: object reference.  Not right!
          $row[13] = 'YELLOW';
        } else if (preg_match('/^grinnell\-auth\:/', trim($part))) {   // this is an old grinnell-auth: object reference.  Not right!
          $row[13] = 'YELLOW';
        } else if (!preg_match('/.+\:.+/', trim($part))) {  // no colon present...this isn't even a proper reference!
          $row[13] = 'RED';
        }
      }
    }
  }

  // Check for NO dc.description.  Unless this is a pageCModel we have a problem.

  $nDC = 0;
  if (!empty($columns[14])) { list($nDC, $content) = idu_get_count_and_content($columns[14]); }
  if ($nDC < 1 && $cModel != 'pageCModel') {
    $row[14] = 'YELLOW';
    $isGreen = FALSE;
  }

  // Mark special circumstances in ORANGE.
  //

  // Get the object's cModel (and CM count).
  list($nCM, $cModel) = idu_get_count_and_content($columns[5]);
  $pid = $columns[2];

  // 1) Any object with a mis-match of legitimate children and constituents.  These should be RED!
  // But consider these conditions...
  //   a) An object with NO constituents is legit if it had only one old content datastream and is not tagged as compound.
  //   b) A pageCModel object will have NO constituents, but should have 3 old content datastreams.
  //   c) A bookCModel should have one content datastream, but more than one constituent.

  list($nCol, $collection) = idu_get_count_and_content($columns[6]);
  list($nK, $oldKids) = idu_get_count_and_content($columns[11]);
  list($nC, $constituents) = idu_get_count_and_content($columns[12]);

  if ($nK != $nC) {

    // Check for case a.
    if ($nC === 0 && $nK === 1) {             // this condition is OK, except if the $cModel is compoundCModel.
      if ($cModel === 'compoundCModel') {
        $row[5] = 'RED';
        $row[12] = 'RED';
        $isGreen = FALSE;
      }

      // Check for case b.
    } else if ($cModel === 'pageCModel') {
      if ($nK != 3 && $nC > 0) {
        $row[5] = 'RED';
        $row[12] = 'RED';
        $isGreen = FALSE;
      }


    // Check for case C.
    } else if ($cModel === 'bookCModel') {
      if ($nK != 1 || $nC < 2) {
        $row[5] = 'RED';
        $row[12] = 'RED';
        $isGreen = FALSE;
      }

    // All others are suspect.
    } else {
      $pending = "# Applying rule 1.\ndrush ficM $pid --replace --collection=$collection\n";
      file_put_contents("public://pending_drush_commands.sh", $pending, FILE_APPEND);
      $row[11] = 'RED';
      $row[12] = 'RED';
      $isGreen = FALSE;
    }
  }

  // 2) A non-compound, non-book object with constituents!  If the object has an OBJ and only one
  //    legitimate content datastream, then we need to delete the constituents.
  //

  if ($nK == 1 && $nC > 0 && $cModel != 'compoundCModel' && $cModel != 'bookCModel') {
    $row[5] = 'ORANGE';
    $isGreen = FALSE;

    if ($nCM == 1) {
      $OBJMimes = rcOBJMimes();
      if ($columns[7] === $OBJMimes[$cModel]) {   // the object has the right OBJ type..good-to-go for deletion of the bogus kids
        $parts = explode(',' , $constituents);
        foreach ($parts as $part) {
          if (preg_match('/^(\d+)\-(\d+)$/', $part, $matches)) {    // got a range of objects
            $pending = "# Applying rule 2.\ndrush iduF $matches[1] $matches[2] PURGE\n";
          } else {                                                    // got a single object
            $pending = "# Applying rule 2.\ndrush iduF $part $part PURGE\n";
          }
          file_put_contents("public://pending_drush_commands.sh", $pending, FILE_APPEND);
        }
      }
    }
  }

  // 3) A compound object with the same number of TIFF and JPEG pairs.
  //

  if ($cModel == 'compoundCModel' && idu_special_case2($columns[11])) {   // Special case 2... TIFF/JPEG pairs!
    $row[2] = 'ORANGE';    
    $isGreen = FALSE;
  }

  // 4) A compound object with only one legitimate constituent and one legit content datastream!

  if ($cModel === 'compoundCModel') {
    if ($nK == $nC && $nC == 1) {
      $row[5] = 'ORANGE';
      $isGreen = FALSE;
      $ns = variable_get('icg_namespace');
      $pending = "# Applying rule 4.\ndrush iduS SingleCompound $ns$columns[1] $ns$constituents\n";
      file_put_contents("public://pending_drush_commands.sh", $pending, FILE_APPEND);
    }
  }

  // If $isGreen is TRUE, set the full PID to green!
  if ($isGreen) { $row[2] = 'GREEN'; } 
      
  return $row;
}

/**
 * Fill a row of the worksheet ($filled) with existing data and format codes.
 *
 * Fill undefined/empty cells in the CSV data with 'NONE' for reporting.
 * 
 * @param array $columns
 *   Associative array of $col => $data pairs.
 * @param array $codes
 *   Associative array of $col => $code pairs.
 *
 * @return array
 */
function idu_fill_sheet($columns, $codes) {
  static $previous = 0;
  $filled = array( );
  $max = max(array_keys($columns));

  for ($c=1; $c<=$max; $c++) {

    // Use column 1 to check for gaps in numbering.
    if ($c == 1) {
      if ($previous == 0) {
        $codes[1] = 'ORANGE';
      } else {
        $change = intval($columns[1]) - $previous;
        if ($change > 4) {
          $codes[1] = 'ORANGE';
        } else if ($change > 1) {
          $codes[1] = 'YELLOW';
        } else {
          unset($codes[1]);
        }
      }
      $previous = intval($columns[1]);
    }

    // Now, apply the codes.
    if (empty($columns[$c])) {
      $filled[$c-1] = '%SOFT%NONE';
    } else if (isset($codes[$c])) {
      $filled[$c-1] = '%'.$codes[$c].'%'.$columns[$c];
    } else {
      $filled[$c-1] = $columns[$c];
    }
  }
  return $filled;
}

/**
 * Returns the largest existing PID number found in the specified range.
 * 
 * @return int
 *   The PID number of the last/highest numbered PID found in the range.
 *   The variable icg_last is automatically set to this limiting value.  If NO objects are found this function
 *   kills the process it was called from.
 */
function idu_getLargestPID( ) {
  $first = intval(variable_get('icg_first'));
  $last = intval(variable_get('icg_last'));
  
  $ns = variable_get('icg_namespace');

  // Loop backwards through the repo looking for the first (last) object in 
  // the specified range.

  for ($i=$last; $i>=$first; $i--) {
    $pid = $ns.$i;
    try {
      $object = idu_repo( )->getObject($pid);
    } catch (Exception $e) {
      if ($e->getCode() != 404) {
        drupal_set_message("PID '$pid' forced a FedoraRepository getObject( ) exception: '$e' ", 'error');
      }
      continue;  // for any exception...skip this PID
    }

    // Got one.  Set icg_last and return $i.
    if ($i < $last) {
      variable_set('icg_last', $i);
      drupal_set_message("Largest PID '$i' found as upper limit of specified range.", 'status');
    }
    return $i;
  }

  // Found nothing.  Kill the operation.
  die("idu_getLargestPID( ) found NO OBJECTS in the specified range.  This process is terminated.  \n");
}

function idu_quick_fix($r, &$object) {
  if ($cell = or_get(6, $r)) {
    list($count, $content) = idu_get_count_and_content($cell);
    if ($count < 2) { return 0; }
  } else {
    return 0;
  }
  
  if (!$ds = $object['RELS-EXT']) { return 0; }
  $rx = $ds->content;
  $xml = new SimpleXMLElement($rx);
  $fixed = 0;
    
  // Remove any/all isMemberOfCollection nodes with text()='grinnell:generic'.
  // The collection name, grinnell:generic, belongs in the attribute, not the value!
  if ($node = $xml->xpath("/rdf:RDF/rdf:Description/islandora:isMemberOfCollection[text()='grinnell:generic']")) {
    if (!empty($node)) {
      foreach($node as $n) { 
        unset($n[0]); 
        ++ $fixed;
      }
      $string = $xml->asXML( );
      $object['RELS-EXT']->setContentfromString($string);
      ++ $fixed;
    }
  }
    
  // Remove any/all isMemberOfCollection nodes with an attribute of islandora:genericCollection.
  if ($node = $xml->xpath("/rdf:RDF/rdf:Description/islandora:isMemberOfCollection[@rdf:resource='info:fedora/islandora:genericCollection']")) {
    if (!empty($node)) {
      foreach($node as $n) { 
        unset($n[0]); 
        ++ $fixed;
      }
      $string = $xml->asXML( );
      $object['RELS-EXT']->setContentfromString($string);
    }
  }
    
  // Now, find all duplicate isMemberOfCollection relationships and remove the duplicate.
  $rels = $object->relationships->get(ISLANDORA_RELS_EXT_URI, 'isMemberOfCollection');
  $found = array( );
  $removed = array( );
  
  // Special fix...if $nRels == 0, make this part of 'grinnell:generic'.
  $nRels = count($rels);
  if ($nRels === 0) {
    $object->relationships->add(ISLANDORA_RELS_EXT_URI, 'isMemberOfCollection', 'grinnell:generic');
    ++ $fixed;
  }

  foreach ($rels as $rel) { 
    $parent = $rel['object']['value'];
    if (in_array($parent, $found)) {
      $object->relationships->remove(ISLANDORA_RELS_EXT_URI, 'isMemberOfCollection', $parent);  // deletes them ALL
      if  (!in_array($parent, $removed)) { $removed[] = $parent; }
      ++ $fixed;
    } else {
      $found[] = $parent;
    }
    
    // Now, for each collection removed, put one copy back!
    foreach ($removed as $parent) {
      $object->relationships->add(ISLANDORA_RELS_EXT_URI, 'isMemberOfCollection', $parent);
    }
  }
        
  return $fixed;
}

/**
 * Create or Modify an object handle and assign it.
 *
 * This function relies on constants defined in idu_constants.inc.  It attempts to open a new or existing Handle system
 * batch command file and appends necessary commands to this file to create or modify and assign a new handle to the target
 * object.  The batch file is defined in temporary://H_BATCH.  This function does NOT initiate processing of the batch file,
 * that must be done elsewhere.
 *
 * @param FedoraObject $object
 *   The Fedora object for which the handle is created or modified.
 * @param string $op
 *   Set to either 'CREATE' or 'MODIFY'.  If --force is specified this value may be overridden.
 * @param bool $force
 *   If TRUE, this function will continue even if the state of the mods:identifier[@type='hdl'] element is not as expected for the specified $op.
 * @return int
 *   Returns 0 or 1 indicating the number of handles processed.
 */
function idu_handle_create_or_modify($object, $op='CREATE', $force=FALSE) {

  $pid = $object->id;

  // Specify the target batch and log files in temporary://.
  $fileName = 'temporary://'.H_BATCH;
  $logFile = 'temporary://'.H_LOG;

  // Open (or create) the batch file and log file.
  $old = file_exists($fileName);
  if (!$file = fopen($fileName, 'a+')) die("Could not open batch file $fileName!  ");
  if (!$log = fopen($logFile, 'a+')) die("Could not open log file $logFile!  ");

  // Open the MODS datastream, if none... done.
  if (!$mods = $object['MODS']) {
    fprintf($log, "Warning: Object '$pid' has NO MODS record.\n");
    fclose($file);
    fclose($log);
    return 0;
  }

  // Make the MODS content searchable as a SimpleXMLElement object.
  $content = $mods->content;
  $xml = new SimpleXMLElement($content);
  $xpath = "/mods:mods/mods:identifier[@type='hdl']";

  // Does this object already have a handle?
  if ($nodes = $xml->xpath($xpath)) {    // Yes...
    $oldHandle = (string)$nodes[0];
    if ($op === 'CREATE' && !$force) {
      fclose($file);
      fclose($log);
      return 0;
    }
  } else if ($op === 'MODIFY') {        // No existing handle...if Modify we need to adjust or give up.
    if ($force) {
      $op = 'CREATE';
    } else {
      fprintf($log, "Warning: Object '$pid' has no assigned Handle.  Use --force or 'drush iduH $pid Create' if you wish to create one.\n\n");
      fclose($file);
      fclose($log);
      return 0;
    }
  }

  // Appropriate handle status found.  Create or modify one as needed.
  list($ns, $pidn) = explode(':', $pid);

  // If this is a new batch command file, print an AUTHENTICATE command block.
  if (!$old) {
    $cmd  = "AUTHENTICATE PUBKEY:300:0.NA/".H_PREFIX." \n".H_SVRDIR."/admpriv.bin";
    if (H_ADMKEY == ' ') {
      $key = $keyLog = '';
    } else {
      $key = '|'.H_ADMKEY;
      $keyLog = '|***obfuscated*keyphrase***';
    }
    fprintf($file, "%s%s\n\n", $cmd, $key);
    fprintf($log, "%s%s\n\n", $cmd, $keyLog);
  }

  // Set the batch file permissions so that it can be deleted later.
  $path = drupal_realpath($fileName);
  if (!$ok = chmod($path, 0777)) {
    die("Permissions could not be set for batch file $fileName.  ");
  }

  // Build the object handle and handle.net URI for this object.  If the namespace of the object matches the specified
  //   H_NUMERIC_ONLY defined parameter, then use only the numeric part of the $pid; otherwise use the entire $pid.
  //
  $handle = ("$ns:" === H_NUMERIC_ONLY ? $pidn : $pid);
  $hdl = 'http://hdl.handle.net/'.H_PREFIX.'/'.$handle;

  // Sanitize the object ID (title) for Handle!  No double quotes and length no more than 120 characters.
  $handle_title = str_replace('"', "", $object->label);
  if (strlen($handle_title) > 117) {
    $lines = explode("\n", wordwrap($handle_title, 117));
    $handle_title = $lines[0] . "...";
  }

  // Remove all old handle identifiers and add one new HDL identifier element to the MODS.
  $mods = new DOMDocument( );
  $mods->loadXML($content);
  $xpath = new DOMXpath($mods);

  foreach ($xpath->query("/mods:mods/mods:identifier[@type='hdl']") as $node) {
    $parent = $node->parentNode;
    $parent->removeChild($node);    // remove the old handles
  }

  // Add a new type='hdl' identifier.
  $id = $mods->createElement('identifier', $hdl);
  $mods->documentElement->appendChild($id);
  $id->setAttribute('type', 'hdl');

  // Remove all URI and DOI identifier elements found at the first level.
  $types = array("doi", "uri");
  foreach ($types as $type) {
    foreach ($xpath->query("/mods:mods/mods:identifier[@type='$type']") as $node) {
      $parent = $node->parentNode;
      $parent->removeChild($node);    // remove the old element
    }
  }

  // If the object has a 'local' identifier, preserve it.  If not, add the handle as a new local ID.
  $nLocal = 0;
  foreach ($xpath->query("/mods:mods/mods:identifier[@type='local']") as $node) {
    $nLocal++;
  }

  if ($nLocal === 0) {
    $id = $mods->createElement('identifier', $pid);
    $mods->documentElement->appendChild($id);
    $id->setAttribute('type', 'local');
  }

  /* Do NOT add a new type='uri' identifier to match the handle ID.
  $id = $mods->createElement('identifier', $hdl);
  $mods->documentElement->appendChild($id);
  $id->setAttribute('type', 'uri');
  */

  // Save the MODS changes.
  $object['MODS']->setContentFromString($mods->saveXML());

  // Add the appropriate command to the batch file.
  $cmd = "$op ".H_PREFIX."/$handle";
  fprintf($file, "%s\n", $cmd);
  fprintf($log, "%s\n", $cmd);

  $cmd  = "100 HS_ADMIN 86400 1110 ADMIN 300:111111111111:0.NA/".H_PREFIX."\n";
  $cmd .= "8 URL 86400 1110 UTF8 ".H_OBJECT_PATH."$pid\n";
  $cmd .= "9 DESC 86400 1110 UTF8 $handle_title\n";
  fprintf($file, "%s\n", $cmd);
  fprintf($log, "%s\n", $cmd);

  // Close the batch and log files and return 1, the number of objects processed.
  fclose($file);
  fclose($log);

  return 1;
}